<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Data Stream</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Development only-->
    <script src="http://localhost:35729/livereload.js"></script>

    <link rel="stylesheet" href="./uPlot.min.css">
</head>

<body>
    <script src="./uPlot.iife.js"></script>
    <h2 id="wait">Easymon</h2>
    <script>
        const dataRetentionMinutes = 1; // maximum time range, last N minutes.
        const extraBufferCapacity = 20; // 20% of extra (preallocated) buffer datapoints

        const maxBufferLen = 60 * dataRetentionMinutes; // number of actual datapoints
        const maxBufferCap = maxBufferLen + (maxBufferLen * extraBufferCapacity) / 100; // number of actual datapoint

        const numSeriesHeap = 4;
        const numSeries = 1 + numSeriesHeap; // timestamp serie + other series

        const idxTimes = 0;
        const idxHeapAlloc = 1;
        const idxHeapSys = 2;
        const idxHeapIdle = 3;
        const idxHeapInuse = 4;

        const bySizeSizes = 61; // heatmap sizes (buckets)

        var data = {
            // timeseries [0]         -> timestamps
            // [1] to [numSeries - 1] -> timeseries datapoint
            series: new Array(numSeries), // TODO: rename to timeseries 
            lastGCs: new Array(),

            bySize: new Array(4), // [0] min [1] max [2] class sizes [3] live objects
        };

        // TODO: do all init in a single function (and not a bit in data declaration 
        // and the rest in initData)
        function initData() {
            for (let i = 0; i < numSeries; i++) {
                data.series[i] = new Buffer(maxBufferLen, maxBufferCap);
            }
            for (let i = 0; i < data.bySize.length; i++) {
                data.bySize[i] = new Buffer(maxBufferLen, maxBufferCap);
            }
        }

        function pushData(ts, stats) {
            data.series[idxTimes].push(ts); // timestamp
            data.series[idxHeapAlloc].push(stats.Mem.HeapAlloc);
            data.series[idxHeapSys].push(stats.Mem.HeapSys);
            data.series[idxHeapIdle].push(stats.Mem.HeapIdle);
            data.series[idxHeapInuse].push(stats.Mem.HeapInuse);

            pushBySize(stats.Mem.BySize);

            const nanoToSeconds = 1000 * 1000 * 1000;
            let lastGC = Math.floor(stats.Mem.LastGC / nanoToSeconds);

            if (lastGC != data.lastGCs[data.lastGCs.length - 1]) {
                data.lastGCs.push(lastGC);
            }

            // Remove from the lastGCs array the timestamps which are prior to
            // the minimum timestamp in 'series'.
            // TODO: do this in a trimLastGC function
            let mints = data.series[idxTimes]._buf[0];
            let mingc = 0;
            for (let i = 0, n = data.lastGCs.length; i < n; i++) {
                if (data.lastGCs[i] > mints) {
                    break;
                }
                mingc = i;
            }
            data.lastGCs.splice(0, mingc);
        }

        function pushBySize(bySize) {
            let sizesIndices = new Array(bySize.length);
            let counts = new Array(bySize.length);

            for (let i = 0; i < bySize.length; i++) {
                const size = bySize[i];
                sizesIndices[i] = i;
                counts[i] = size.Mallocs - size.Frees;
            }

            // TODO data.bySize[0] [1] and [2] in theory never change so there 
            // should be no need to recreate it each time.
            data.bySize[0].push(0);
            data.bySize[1].push(sizesIndices.length - 1);
            data.bySize[2].push(sizesIndices);
            data.bySize[3].push(counts);
        }

        // Contain indexed class sizes, this is initialized after reception of the first message.
        var classSizes = new Array();

        function initClassSizes(bySize) {
            for (let i = 0; i < bySize.length; i++) {
                classSizes.push(bySize[i].Size);
            }
        }

        // Slice data in order to keep the last nitems contained in the raw data.
        // TODO: rename sliceSeries or sliceHeap
        function sliceData(nitems) {
            let d = new Array(numSeries);
            for (let i = 0; i < numSeries; i++) {
                d[i] = data.series[i].slice(nitems);
            }

            return d;
        }

        function sliceHeatmapData(nitems) {
            let d = new Array(5);
            // TODO : could reuse the timestamp slice since it has already been
            // sliced previously (in sliceData).
            d[0] = data.series[idxTimes].slice(nitems);
            d[1] = data.bySize[0].slice(nitems);
            d[2] = data.bySize[1].slice(nitems);
            d[3] = data.bySize[2].slice(nitems);
            d[4] = data.bySize[3].slice(nitems);

            return d;
        }

        function nowts() {
            var d = new Date();
            return Math.round(d.getTime() / 1000);
        }

        function humanFileSize(bytes, si = false, dp = 1) {
            const thresh = si ? 1000 : 1024;

            if (Math.abs(bytes) < thresh) {
                return bytes + ' B';
            }

            const units = si
                ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
            let u = -1;
            const r = 10 ** dp;

            do {
                bytes /= thresh;
                ++u;
            } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);

            return bytes.toFixed(dp) + ' ' + units[u];
        }

        function valueFmt(u, v) {
            return humanFileSize(v, true);
        }

        const cursorOpts = {
            lock: true,
            focus: {
                prox: 16,
            },
            points: {
                show: false,
            },
            sync: {
                key: "ts",
                setSeries: true,
            },
        };

        function gcLinesPlugin() {
            return {
                hooks: {
                    draw: u => {
                        const { ctx } = u;
                        const gcs = data.lastGCs;
                        const mints = u.data[idxTimes][0];
                        const maxts = u.data[idxTimes][u.data[idxTimes].length - 1];
                        const y0 = u.valToPos(u.scales['b'].min, 'b', true);
                        const y1 = u.valToPos(u.scales['b'].max, 'b', true);

                        for (let i = 0, n = gcs.length; i < n; i++) {
                            const ts = gcs[i];
                            if (ts < mints || ts > maxts) {
                                continue;
                            }

                            const x = u.valToPos(ts, 'x', true);
                            ctx.beginPath();
                            ctx.moveTo(x, y0);
                            ctx.lineTo(x, y1);
                            ctx.setLineDash([5, 10]);
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = 'grey';
                            ctx.stroke();
                        }
                    }
                }
            };
        }

        const opts1 = {
            title: "Heap",
            width: 800,
            height: 600,
            cursor: cursorOpts,
            plugins: [
                gcLinesPlugin(),
            ],
            series: [
                {},
                {
                    label: "HeapAlloc",
                    scale: "b",
                    value: valueFmt,
                    stroke: "red",
                    points: {
                        show: true,
                        size: 3,
                        fill: "red",
                    },
                },
                {
                    label: "HeapSys",
                    scale: "b",
                    value: valueFmt,
                    stroke: "blue",
                    points: {
                        show: true,
                        size: 3,
                        fill: "blue",
                    },
                },
                {
                    label: "HeapIdle",
                    scale: "b",
                    value: valueFmt,
                    stroke: "green",
                    points: {
                        show: true,
                        size: 3,
                        fill: "green",
                    },
                },
                {
                    label: "HeapInuse",
                    scale: "b",
                    value: valueFmt,
                    stroke: "orange",
                    points: {
                        show: true,
                        size: 3,
                        fill: "orange",
                    },
                },
            ],
            axes: [
                {
                    values: (u, vals, space) => vals.map(v => formatTimestamps(v)),
                    rotate: 50,
                },
                {
                    scale: 'b',
                    values: (u, vals, space) => vals.map(v => humanFileSize(v, true, 0)),
                    size: 90,
                },
            ],
        };

        function formatTimestamps(ts) {
            let d = new Date(ts * 1000);
            let h = d.getHours()
            let m = d.getMinutes()
            let s = d.getSeconds()

            if (s % 5 == 0) {
                // hh:mm:ss
                return h.toString().padStart(2, '0')
                    + ":" + m.toString().padStart(2, '0')
                    + ":" + s.toString().padStart(2, '0')
            }

            // ss
            return s.toString().padStart(2, '0')
        }

        function heatmapPlugin() {
            // let global min/max
            function fillStyle(count, maxCount) {
                const norm = count / maxCount;

                // salmon
                // const r = 254 - (24 * norm);
                // const g = 230 - (145 * norm);
                // const b = 206 - (193 * norm);

                // purple
                const r = 239 - (122 * norm);
                const g = 237 - (120 * norm);
                const b = 245 - (68 * norm);
                return `rgba(${r}, ${g}, ${b}, 1)`;
            }

            return {
                hooks: {
                    draw: u => {
                        const { ctx, data } = u;

                        let yData = data[3];
                        let yQtys = data[4];
                        const rectw = u.bbox.width / data[0].length;
                        const recth = u.bbox.height / classSizes.length;

                        let maxCount = -Infinity;

                        yQtys.forEach(qtys => {
                            maxCount = Math.max(maxCount, Math.max.apply(null, qtys));
                        });

                        yData.forEach((yVals, xi) => {
                            let xPos = u.valToPos(data[0][xi], 'x', true);

                            yVals.forEach((yVal, yi) => {
                                const count = yQtys[xi][yi];
                                if (count == 0) {
                                    // Skip empty size classes
                                    return;
                                }
                                const yPos = Math.round(u.valToPos(yVal, 'y', true));
                                ctx.fillStyle = fillStyle(count, maxCount);
                                ctx.fillRect(xPos, yPos, rectw, recth);
                            });
                        });
                    }
                }
            };
        }

        const opts2 = {
            title: "Size classes Heatmap",
            width: 800,
            height: 600,
            cursor: cursorOpts,
            plugins: [
                heatmapPlugin(),
            ],
            series: [
                {
                    scale: 'x',
                },
                {
                    paths: () => null,
                    points: { show: false },
                    scale: 'y',
                },
                {
                    paths: () => null,
                    points: { show: false },
                    scale: 'y',
                },
            ],
            axes: [
                {
                    scale: 'x',
                    values: (u, vals, space) => vals.map(v => formatTimestamps(v)),
                    rotate: 50,
                },
                {
                    scale: 'y',
                    values: (u, vals, space) => vals.map(function (i) {
                        if (i > classSizes.length - 1) {
                            return '';
                        }
                        return humanFileSize(classSizes[i], true, 0);
                    }),
                    size: 90,
                },
            ],
        };

        // TODO: either remove plotCtx and declare uplot1, uplot2 etc as free variables or 
        // move all in plotCtx: the plots and the data.
        let plotCtx = {
            uplot1: null, // Heap plot group
            uplot2: null, // BySize heapmap
        };

        function buildWebsocketURI(params) {
            var loc = window.location, ws_prot = "ws:";
            if (loc.protocol === "https:") {
                ws_uri = "wss:";
            }
            return ws_prot + "//" + loc.host + loc.pathname + "ws"
        }

        let socket = new WebSocket(buildWebsocketURI());
        console.log("Attempting Connection...");

        socket.onopen = () => {
            console.log("Successfully Connected");
            initData();
        };

        socket.onclose = event => {
            console.log("Socket Closed Connection: ", event);
            socket.send("Client Closed!")
        };

        socket.onerror = error => {
            console.log("Socket Error: ", error);
        };

        socket.onmessage = event => {
            stats = JSON.parse(event.data);
            console.log("Received stats: ", stats);

            let now = nowts();
            pushData(now, stats);

            let numTs = maxBufferLen;
            let data1 = sliceData(numTs);
            let data2 = sliceHeatmapData(numTs);

            if (plotCtx.uplot1 == null) {
                if (data.series[idxTimes].length() < 2) {
                    return
                }
                initClassSizes(stats.Mem.BySize);
                plotCtx.uplot1 = new uPlot(opts1, data1, document.body);
                plotCtx.uplot2 = new uPlot(opts2, data2, document.body);
            }

            let xScale = {
                min: now - 60,
                max: now,
            };

            plotCtx.uplot1.batch(() => {
                plotCtx.uplot1.setData(data1);
                plotCtx.uplot1.setScale("x", xScale);
            });
            plotCtx.uplot2.batch(() => {
                plotCtx.uplot2.setData(data2);
                plotCtx.uplot2.setScale("x", xScale);
            });
        }


        function Buffer(len, cap) {
            if (cap - len < 0) {
                console.Error("cap - len must be positive");
            }

            // TODO(arl): value using TypedArray rather than Array here
            this._buf = new Array(cap);
            this._pos = 0;
            this._len = len;
            this._cap = cap;
        }

        Buffer.prototype.last = function () {
            if (this.length() == 0) {
                throw 'Cannot call last() on an empty Buffer';
            }
            return this._buf[this._pos]
        }

        Buffer.prototype.push = function (pt) {
            if (this._pos >= this._cap) {
                // move data to the beggining of the buffer, effectively discarding
                // the cap-len oldest elements
                this._buf.copyWithin(0, this._cap - this._len);
                this._pos = this._len;
            }

            this._buf[this._pos] = pt;
            this._pos++;
        }

        Buffer.prototype.length = function () {
            if (this._pos > this._len) {
                return this._len;
            }

            return this._pos;
        }

        // slice returns a slice of the len latest datapoints present in the buffer.
        Buffer.prototype.slice = function (len) {
            // Cap the dimension of the returned slice to the data available
            if (len > this.length()) {
                len = this.length();
            }

            let start = this._pos - len;
            return this._buf.slice(start, start + len);
        }
    </script>
</body>

</html>