//go:build go1.19
// +build go1.19

package plot

import (
	"runtime/metrics"
)

/*
 * GC cycles
 */
var _ = registerRuntimePlot("gc-cycles",
	"/gc/cycles/automatic:gc-cycles",
	"/gc/cycles/forced:gc-cycles",
	"/gc/cycles/total:gc-cycles",
)

func init() {
	registerPlotFunc(makeGCCyclesPlot)
}

type gcCycles struct {
	enabled bool

	idxAutomatic int
	idxForced    int
	idxTotal     int

	lastAuto, lastForced, lastTotal uint64
}

func makeGCCyclesPlot(idxs map[string]int) runtimeMetric {
	idxAutomatic, ok1 := idxs["/gc/cycles/automatic:gc-cycles"]
	idxForced, ok2 := idxs["/gc/cycles/forced:gc-cycles"]
	idxTotal, ok3 := idxs["/gc/cycles/total:gc-cycles"]

	return &gcCycles{
		enabled:      ok1 && ok2 && ok3,
		idxAutomatic: idxAutomatic,
		idxForced:    idxForced,
		idxTotal:     idxTotal,
	}
}

func (p *gcCycles) name() string    { return "gc-cycles" }
func (p *gcCycles) isEnabled() bool { return p.enabled }

func (p *gcCycles) layout(_ []metrics.Sample) any {
	s := Scatter{
		Name:  p.name(),
		Title: "Completed GC Cycles",
		Type:  "bar",
		Subplots: []Subplot{
			{
				Name:       "forced",
				Unitfmt:    "%{y}",
				HoverOn:    "points",
				StackGroup: "one",
			},
			{
				Name:       "automatic",
				Unitfmt:    "%{y}",
				HoverOn:    "points",
				StackGroup: "one",
			},
		},
		InfoText: `Number of completed GC cycles, either forced of generated by the Go runtime.`,
	}
	s.Layout.Yaxis.Title = "objects"
	return s
}

func (p *gcCycles) values(samples []metrics.Sample) any {
	total := samples[p.idxTotal].Value.Uint64()
	forced := samples[p.idxForced].Value.Uint64()
	auto := samples[p.idxAutomatic].Value.Uint64()

	if p.lastTotal == 0 {
		p.lastTotal = total
		p.lastForced = forced
		p.lastAuto = auto
		return []uint64{0, 0}
	}

	ret := []uint64{
		forced - p.lastForced,
		auto - p.lastAuto,
	}

	p.lastForced = forced
	p.lastAuto = auto

	return ret
}
