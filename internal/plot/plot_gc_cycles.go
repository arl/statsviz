package plot

import "runtime/metrics"

type gcCycles struct {
	idxAutomatic int
	idxForced    int
	idxTotal     int

	lastAuto, lastForced, lastTotal uint64
}

func makeGCCycles(indices ...int) metricsGetter {
	return &gcCycles{
		idxAutomatic: indices[0],
		idxForced:    indices[1],
		idxTotal:     indices[2],
	}
}

func (p *gcCycles) values(samples []metrics.Sample) any {
	total := samples[p.idxTotal].Value.Uint64()
	auto := samples[p.idxAutomatic].Value.Uint64()
	forced := samples[p.idxForced].Value.Uint64()

	if p.lastTotal == 0 {
		p.lastTotal = total
		p.lastForced = forced
		p.lastAuto = auto
		return []uint64{0, 0}
	}

	ret := []uint64{
		auto - p.lastAuto,
		forced - p.lastForced,
	}

	p.lastForced = forced
	p.lastAuto = auto

	return ret
}

var gcCyclesLayout = Scatter{
	Name:  "TODO(set later)",
	Title: "Completed GC Cycles",
	Type:  "bar",
	Layout: ScatterLayout{
		BarMode: "stack",
		Yaxis: ScatterYAxis{
			Title: "cycles",
		},
	},
	Subplots: []Subplot{
		{
			Name:    "automatic",
			Unitfmt: "%{y}",
			Type:    "bar",
		},
		{
			Name:    "forced",
			Unitfmt: "%{y}",
			Type:    "bar",
		},
	},
	InfoText: `Number of completed GC cycles, either forced of generated by the Go runtime.`,
}
